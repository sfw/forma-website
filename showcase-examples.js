/* Generated from forma/examples/showcase/*.forma */
/* Regenerate with local tooling if showcase examples change. */

window.FORMA_SHOWCASE_EXAMPLES = [
  {
    "id": "01_hello_world",
    "file": "01_hello_world.forma",
    "title": "Hello World",
    "tier": "Tier 1 - Basic",
    "description": "The canonical first program.",
    "concepts": "basic output, string literals",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/01_hello_world.forma",
    "code": "# Hello World - The canonical first program\n# Demonstrates: basic output, string literals\n\nf main()\n    print(\"Hello, World!\")\n"
  },
  {
    "id": "02_fizzbuzz",
    "file": "02_fizzbuzz.forma",
    "title": "FizzBuzz",
    "tier": "Tier 1 - Basic",
    "description": "Classic interview problem.",
    "concepts": "loops, conditionals, modulo, string output",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/02_fizzbuzz.forma",
    "code": "# FizzBuzz - Classic interview problem\n# Demonstrates: loops, conditionals, modulo, string output\n#\n# Print numbers 1 to N, but:\n#   - for multiples of 3, print \"Fizz\"\n#   - for multiples of 5, print \"Buzz\"\n#   - for multiples of both, print \"FizzBuzz\"\n\nf fizzbuzz(n: Int) -> Unit\n    i := 1\n    wh i <= n\n        if i % 15 == 0 then\n            print(\"FizzBuzz\")\n        else if i % 3 == 0 then\n            print(\"Fizz\")\n        else if i % 5 == 0 then\n            print(\"Buzz\")\n        else\n            print(i)\n        i := i + 1\n\nf main()\n    fizzbuzz(100)\n"
  },
  {
    "id": "03_99_bottles",
    "file": "03_99_bottles.forma",
    "title": "99 Bottles of Beer",
    "tier": "Tier 1 - Basic",
    "description": "Classic loop exercise.",
    "concepts": "loops, string interpolation, conditionals",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/03_99_bottles.forma",
    "code": "# 99 Bottles of Beer - Classic loop exercise\n# Demonstrates: loops, string interpolation, conditionals\n\nf bottles(n: Int) -> String\n    if n == 0 then \"no more bottles\"\n    else if n == 1 then \"1 bottle\"\n    else f\"{n} bottles\"\n\nf verse(n: Int) -> Unit\n    if n == 0 then\n        print(\"No more bottles of beer on the wall, no more bottles of beer.\")\n        print(\"Go to the store and buy some more, 99 bottles of beer on the wall.\")\n    else\n        print(f\"{bottles(n)} of beer on the wall, {bottles(n)} of beer.\")\n        print(f\"Take one down and pass it around, {bottles(n - 1)} of beer on the wall.\")\n        print(\"\")\n\nf main()\n    n := 99\n    wh n >= 0\n        verse(n)\n        n := n - 1\n"
  },
  {
    "id": "04_factorial",
    "file": "04_factorial.forma",
    "title": "Factorial",
    "tier": "Tier 2 - Mathematical",
    "description": "Classic recursion example.",
    "concepts": "recursion, conditionals, large numbers",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/04_factorial.forma",
    "code": "# Factorial - Classic recursion example\n# Demonstrates: recursion, conditionals, large numbers\n#\n# n! = n * (n-1) * (n-2) * ... * 1\n# 0! = 1 by definition\n\n# Recursive version\nf factorial_rec(n: Int) -> Int\n    if n <= 1 then 1\n    else n * factorial_rec(n - 1)\n\n# Tail-recursive version with accumulator\nf factorial_tail(n: Int, acc: Int) -> Int\n    if n <= 1 then acc\n    else factorial_tail(n - 1, acc * n)\n\nf factorial(n: Int) -> Int\n    factorial_tail(n, 1)\n\n# Iterative version\nf factorial_iter(n: Int) -> Int\n    result := 1\n    i := 2\n    wh i <= n\n        result := result * i\n        i := i + 1\n    result\n\nf main()\n    print(\"Factorial examples:\")\n    print(f\"5! = {factorial(5)}\")           # 120\n    print(f\"10! = {factorial(10)}\")         # 3628800\n    print(f\"12! = {factorial(12)}\")         # 479001600\n    print(f\"20! = {factorial(20)}\")         # 2432902008176640000\n\n    print(\"\")\n    print(\"Comparing implementations:\")\n    print(f\"factorial_rec(10) = {factorial_rec(10)}\")\n    print(f\"factorial_tail(10, 1) = {factorial_tail(10, 1)}\")\n    print(f\"factorial_iter(10) = {factorial_iter(10)}\")\n"
  },
  {
    "id": "05_fibonacci",
    "file": "05_fibonacci.forma",
    "title": "Fibonacci Sequence",
    "tier": "Tier 2 - Mathematical",
    "description": "Classic recursion/dynamic programming example.",
    "concepts": "recursion, iteration, memoization patterns",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/05_fibonacci.forma",
    "code": "# Fibonacci Sequence - Classic recursion/dynamic programming example\n# Demonstrates: recursion, iteration, memoization patterns\n#\n# F(0) = 0, F(1) = 1\n# F(n) = F(n-1) + F(n-2)\n# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...\n\n# Naive recursive (exponential time - O(2^n))\nf fib_rec(n: Int) -> Int\n    if n <= 0 then 0\n    else if n == 1 then 1\n    else fib_rec(n - 1) + fib_rec(n - 2)\n\n# Iterative (linear time - O(n))\nf fib_iter(n: Int) -> Int\n    if n <= 0 then 0\n    else if n == 1 then 1\n    else\n        a := 0\n        b := 1\n        i := 2\n        wh i <= n\n            temp := a + b\n            a := b\n            b := temp\n            i := i + 1\n        b\n\n# Print first n Fibonacci numbers\nf print_fibs(n: Int) -> Unit\n    i := 0\n    wh i < n\n        print(f\"F({i}) = {fib_iter(i)}\")\n        i := i + 1\n\nf main()\n    print(\"First 20 Fibonacci numbers:\")\n    print_fibs(20)\n\n    print(\"\")\n    print(\"Larger values (iterative):\")\n    print(f\"F(30) = {fib_iter(30)}\")    # 832040\n    print(f\"F(40) = {fib_iter(40)}\")    # 102334155\n    print(f\"F(50) = {fib_iter(50)}\")    # 12586269025\n"
  },
  {
    "id": "06_primes",
    "file": "06_primes.forma",
    "title": "Prime Numbers",
    "tier": "Tier 2 - Mathematical",
    "description": "Sieve of Eratosthenes.",
    "concepts": "arrays, nested loops, algorithm optimization",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/06_primes.forma",
    "code": "# Prime Numbers - Sieve of Eratosthenes\n# Demonstrates: arrays, nested loops, algorithm optimization\n#\n# Find all prime numbers up to n using the ancient algorithm\n\n# Check if a number is prime (simple method)\nf is_prime(n: Int) -> Bool\n    if n < 2 then false\n    else if n == 2 then true\n    else if n % 2 == 0 then false\n    else\n        i := 3\n        wh i * i <= n\n            if n % i == 0 then\n                return false\n            i := i + 2\n        true\n\n# Count primes up to n using trial division\nf count_primes(n: Int) -> Int\n    count := 0\n    i := 2\n    wh i <= n\n        if is_prime(i) then\n            count := count + 1\n        i := i + 1\n    count\n\n# Print primes up to n\nf print_primes(n: Int) -> Unit\n    print(f\"Primes up to {n}:\")\n    i := 2\n    wh i <= n\n        if is_prime(i) then\n            print(i)\n        i := i + 1\n\n# Find the nth prime\nf nth_prime(n: Int) -> Int\n    count := 0\n    candidate := 2\n    wh count < n\n        if is_prime(candidate) then\n            count := count + 1\n            if count == n then\n                return candidate\n        candidate := candidate + 1\n    0\n\nf main()\n    print_primes(50)\n\n    print(\"\")\n    print(f\"Number of primes up to 100: {count_primes(100)}\")   # 25\n    print(f\"Number of primes up to 1000: {count_primes(1000)}\") # 168\n\n    print(\"\")\n    print(f\"The 10th prime is: {nth_prime(10)}\")   # 29\n    print(f\"The 100th prime is: {nth_prime(100)}\") # 541\n"
  },
  {
    "id": "07_gcd_lcm",
    "file": "07_gcd_lcm.forma",
    "title": "GCD and LCM",
    "tier": "Tier 2 - Mathematical",
    "description": "Euclidean Algorithm.",
    "concepts": "recursion, mathematical algorithms",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/07_gcd_lcm.forma",
    "code": "# GCD and LCM - Euclidean Algorithm\n# Demonstrates: recursion, mathematical algorithms\n#\n# GCD (Greatest Common Divisor) using Euclid's algorithm\n# LCM (Least Common Multiple) using GCD\n\n# Euclidean algorithm (recursive)\nf gcd(a: Int, b: Int) -> Int\n    if b == 0 then abs(a)\n    else gcd(b, a % b)\n\n# Iterative version\nf gcd_iter(a: Int, b: Int) -> Int\n    x := abs(a)\n    y := abs(b)\n    wh y != 0\n        temp := y\n        y := x % y\n        x := temp\n    x\n\n# LCM using GCD (avoid overflow by dividing first)\nf lcm(a: Int, b: Int) -> Int\n    if a == 0 || b == 0 then 0\n    else abs(a / gcd(a, b)) * abs(b)\n\n# Extended Euclidean algorithm\n# Returns (gcd, x, y) such that a*x + b*y = gcd(a,b)\nf extended_gcd(a: Int, b: Int) -> (Int, Int, Int)\n    if b == 0 then\n        (abs(a), 1, 0)\n    else\n        result := extended_gcd(b, a % b)\n        g := result.0\n        x := result.1\n        y := result.2\n        (g, y, x - (a / b) * y)\n\nf main()\n    print(\"GCD examples:\")\n    print(f\"gcd(48, 18) = {gcd(48, 18)}\")       # 6\n    print(f\"gcd(54, 24) = {gcd(54, 24)}\")       # 6\n    print(f\"gcd(17, 13) = {gcd(17, 13)}\")       # 1 (coprime)\n    print(f\"gcd(100, 35) = {gcd(100, 35)}\")     # 5\n\n    print(\"\")\n    print(\"LCM examples:\")\n    print(f\"lcm(4, 6) = {lcm(4, 6)}\")           # 12\n    print(f\"lcm(21, 6) = {lcm(21, 6)}\")         # 42\n    print(f\"lcm(12, 18) = {lcm(12, 18)}\")       # 36\n\n    print(\"\")\n    print(\"Extended GCD (Bezout coefficients):\")\n    result := extended_gcd(35, 15)\n    print(f\"extended_gcd(35, 15) = ({result.0}, {result.1}, {result.2})\")\n    print(f\"Verification: 35 * {result.1} + 15 * {result.2} = {35 * result.1 + 15 * result.2}\")\n"
  },
  {
    "id": "08_hanoi",
    "file": "08_hanoi.forma",
    "title": "Tower of Hanoi",
    "tier": "Tier 3 - Classic Algorithms",
    "description": "Classic recursion puzzle.",
    "concepts": "recursion, problem decomposition",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/08_hanoi.forma",
    "code": "# Tower of Hanoi - Classic recursion puzzle\n# Demonstrates: recursion, problem decomposition\n#\n# Move n disks from source peg to target peg using auxiliary peg.\n# Rules:\n#   1. Only one disk can be moved at a time\n#   2. A larger disk cannot be placed on a smaller disk\n\nf hanoi(n: Int, source: String, target: String, auxiliary: String) -> Unit\n    if n == 1 then\n        print(f\"Move disk 1 from {source} to {target}\")\n    else\n        # Move n-1 disks from source to auxiliary\n        hanoi(n - 1, source, auxiliary, target)\n        # Move the largest disk from source to target\n        print(f\"Move disk {n} from {source} to {target}\")\n        # Move n-1 disks from auxiliary to target\n        hanoi(n - 1, auxiliary, target, source)\n\n# Count total moves for n disks (2^n - 1)\nf hanoi_moves(n: Int) -> Int\n    if n <= 0 then 0\n    else\n        result := 1\n        i := 0\n        wh i < n\n            result := result * 2\n            i := i + 1\n        result - 1\n\nf main()\n    print(\"Tower of Hanoi with 3 disks:\")\n    print(\"============================\")\n    hanoi(3, \"A\", \"C\", \"B\")\n\n    print(\"\")\n    print(\"Move counts:\")\n    print(f\"3 disks: {hanoi_moves(3)} moves\")   # 7\n    print(f\"4 disks: {hanoi_moves(4)} moves\")   # 15\n    print(f\"5 disks: {hanoi_moves(5)} moves\")   # 31\n    print(f\"10 disks: {hanoi_moves(10)} moves\") # 1023\n\n    print(\"\")\n    print(\"Tower of Hanoi with 4 disks:\")\n    print(\"============================\")\n    hanoi(4, \"A\", \"C\", \"B\")\n"
  },
  {
    "id": "09_nqueens",
    "file": "09_nqueens.forma",
    "title": "N-Queens Problem",
    "tier": "Tier 3 - Classic Algorithms",
    "description": "Classic backtracking puzzle.",
    "concepts": "backtracking, array manipulation, recursion",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/09_nqueens.forma",
    "code": "# N-Queens Problem - Classic backtracking puzzle\n# Demonstrates: backtracking, array manipulation, recursion\n#\n# Place N queens on an NxN chessboard so that no two queens\n# attack each other (no shared row, column, or diagonal)\n\n# Check if placing a queen at (row, col) is safe\n# queens[i] = column position of queen in row i\nf is_safe(queens: [Int], row: Int, col: Int) -> Bool\n    i := 0\n    wh i < row\n        q_col := queens[i]\n        # Check column conflict\n        if q_col == col then\n            return false\n        # Check diagonal conflict\n        if abs(q_col - col) == abs(i - row) then\n            return false\n        i := i + 1\n    true\n\n# Solve N-Queens using backtracking\n# Returns number of solutions found\nf solve_nqueens_count(n: Int, row: Int, ref mut queens: [Int], count: Int) -> Int\n    if row == n then\n        # Found a valid solution\n        count + 1\n    else\n        result := count\n        col := 0\n        wh col < n\n            if is_safe(queens, row, col) then\n                # Place queen and recurse\n                queens[row] := col\n                result := solve_nqueens_count(n, row + 1, ref mut queens, result)\n            col := col + 1\n        result\n\n# Count all solutions for N-Queens\nf nqueens_count(n: Int) -> Int\n    queens := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  # Max 15 queens\n    solve_nqueens_count(n, 0, ref mut queens, 0)\n\n# Print one solution\nf print_solution(queens: [Int], n: Int) -> Unit\n    row := 0\n    wh row < n\n        line := \"\"\n        col := 0\n        wh col < n\n            if queens[row] == col then\n                line := line + \"Q \"\n            else\n                line := line + \". \"\n            col := col + 1\n        print(line)\n        row := row + 1\n\n# Find and print first solution\nf solve_and_print(n: Int, row: Int, ref mut queens: [Int]) -> Bool\n    if row == n then\n        print_solution(queens, n)\n        true\n    else\n        col := 0\n        wh col < n\n            if is_safe(queens, row, col) then\n                queens[row] := col\n                if solve_and_print(n, row + 1, ref mut queens) then\n                    return true\n            col := col + 1\n        false\n\nf main()\n    print(\"N-Queens Solutions Count:\")\n    print(f\"4-Queens: {nqueens_count(4)} solutions\")   # 2\n    print(f\"5-Queens: {nqueens_count(5)} solutions\")   # 10\n    print(f\"6-Queens: {nqueens_count(6)} solutions\")   # 4\n    print(f\"7-Queens: {nqueens_count(7)} solutions\")   # 40\n    print(f\"8-Queens: {nqueens_count(8)} solutions\")   # 92\n\n    print(\"\")\n    print(\"First 8-Queens solution:\")\n    queens := [0, 0, 0, 0, 0, 0, 0, 0]\n    result := solve_and_print(8, 0, ref mut queens)\n"
  },
  {
    "id": "10_quicksort",
    "file": "10_quicksort.forma",
    "title": "Quicksort",
    "tier": "Tier 3 - Classic Algorithms",
    "description": "Classic divide-and-conquer sorting algorithm.",
    "concepts": "recursion, array manipulation, partitioning",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/10_quicksort.forma",
    "code": "# Quicksort - Classic divide-and-conquer sorting algorithm\n# Demonstrates: recursion, array manipulation, partitioning\n#\n# Average case: O(n log n), Worst case: O(n^2)\n\n# Swap two elements in array\nf swap(ref mut arr: [Int], i: Int, j: Int) -> Unit\n    temp := arr[i]\n    arr[i] := arr[j]\n    arr[j] := temp\n\n# Partition array around pivot (last element)\n# Returns index of pivot after partitioning\nf partition(ref mut arr: [Int], low: Int, high: Int) -> Int\n    pivot := arr[high]\n    i := low - 1\n\n    j := low\n    wh j < high\n        if arr[j] <= pivot then\n            i := i + 1\n            swap(ref mut arr, i, j)\n        j := j + 1\n\n    swap(ref mut arr, i + 1, high)\n    i + 1\n\n# Quicksort recursive implementation\nf quicksort(ref mut arr: [Int], low: Int, high: Int) -> Unit\n    if low < high then\n        pi := partition(ref mut arr, low, high)\n        quicksort(ref mut arr, low, pi - 1)\n        quicksort(ref mut arr, pi + 1, high)\n\n# Helper to sort entire array\nf sort(ref mut arr: [Int]) -> Unit\n    n := len(arr)\n    if n > 1 then\n        quicksort(ref mut arr, 0, n - 1)\n\n# Print array\nf print_array(arr: [Int], label: String) -> Unit\n    s := label + \": [\"\n    i := 0\n    wh i < len(arr)\n        if i > 0 then\n            s := s + \", \"\n        s := s + f\"{arr[i]}\"\n        i := i + 1\n    s := s + \"]\"\n    print(s)\n\nf main()\n    # Test 1: Random array\n    arr1 := [64, 34, 25, 12, 22, 11, 90]\n    print_array(arr1, \"Before\")\n    sort(ref mut arr1)\n    print_array(arr1, \"After \")\n\n    print(\"\")\n\n    # Test 2: Already sorted\n    arr2 := [1, 2, 3, 4, 5]\n    print_array(arr2, \"Already sorted before\")\n    sort(ref mut arr2)\n    print_array(arr2, \"Already sorted after \")\n\n    print(\"\")\n\n    # Test 3: Reverse sorted\n    arr3 := [5, 4, 3, 2, 1]\n    print_array(arr3, \"Reverse before\")\n    sort(ref mut arr3)\n    print_array(arr3, \"Reverse after \")\n\n    print(\"\")\n\n    # Test 4: With duplicates\n    arr4 := [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\n    print_array(arr4, \"Duplicates before\")\n    sort(ref mut arr4)\n    print_array(arr4, \"Duplicates after \")\n"
  },
  {
    "id": "11_binary_search",
    "file": "11_binary_search.forma",
    "title": "Binary Search",
    "tier": "Tier 3 - Classic Algorithms",
    "description": "Classic search algorithm.",
    "concepts": "iteration, divide-and-conquer, O(log n) complexity",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/11_binary_search.forma",
    "code": "# Binary Search - Classic search algorithm\n# Demonstrates: iteration, divide-and-conquer, O(log n) complexity\n#\n# Requires sorted array, returns index or -1 if not found\n\n# Iterative binary search\nf binary_search(arr: [Int], target: Int) -> Int\n    left := 0\n    right := len(arr) - 1\n\n    wh left <= right\n        mid := left + (right - left) / 2\n\n        if arr[mid] == target then\n            return mid\n        else if arr[mid] < target then\n            left := mid + 1\n        else\n            right := mid - 1\n\n    0 - 1  # Not found\n\n# Recursive binary search\nf binary_search_rec(arr: [Int], target: Int, left: Int, right: Int) -> Int\n    if left > right then\n        0 - 1  # Not found\n    else\n        mid := left + (right - left) / 2\n        if arr[mid] == target then\n            mid\n        else if arr[mid] < target then\n            binary_search_rec(arr, target, mid + 1, right)\n        else\n            binary_search_rec(arr, target, left, mid - 1)\n\n# Find first occurrence (for duplicates)\nf binary_search_first(arr: [Int], target: Int) -> Int\n    left := 0\n    right := len(arr) - 1\n    result := 0 - 1\n\n    wh left <= right\n        mid := left + (right - left) / 2\n        if arr[mid] == target then\n            result := mid\n            right := mid - 1  # Keep searching left\n        else if arr[mid] < target then\n            left := mid + 1\n        else\n            right := mid - 1\n\n    result\n\n# Find last occurrence (for duplicates)\nf binary_search_last(arr: [Int], target: Int) -> Int\n    left := 0\n    right := len(arr) - 1\n    result := 0 - 1\n\n    wh left <= right\n        mid := left + (right - left) / 2\n        if arr[mid] == target then\n            result := mid\n            left := mid + 1  # Keep searching right\n        else if arr[mid] < target then\n            left := mid + 1\n        else\n            right := mid - 1\n\n    result\n\nf main()\n    arr := [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    print(\"Array: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\")\n\n    print(\"\")\n    print(\"Basic search:\")\n    print(f\"Search for 7: index {binary_search(arr, 7)}\")    # 3\n    print(f\"Search for 1: index {binary_search(arr, 1)}\")    # 0\n    print(f\"Search for 19: index {binary_search(arr, 19)}\")  # 9\n    print(f\"Search for 8: index {binary_search(arr, 8)}\")    # -1\n\n    print(\"\")\n    print(\"Recursive search:\")\n    print(f\"Search for 11: index {binary_search_rec(arr, 11, 0, len(arr) - 1)}\")  # 5\n\n    print(\"\")\n    # Array with duplicates\n    arr2 := [1, 2, 2, 2, 3, 4, 4, 5]\n    print(\"Array with duplicates: [1, 2, 2, 2, 3, 4, 4, 5]\")\n    print(f\"First occurrence of 2: index {binary_search_first(arr2, 2)}\")  # 1\n    print(f\"Last occurrence of 2: index {binary_search_last(arr2, 2)}\")    # 3\n    print(f\"First occurrence of 4: index {binary_search_first(arr2, 4)}\")  # 5\n    print(f\"Last occurrence of 4: index {binary_search_last(arr2, 4)}\")    # 6\n"
  },
  {
    "id": "12_linked_list",
    "file": "12_linked_list.forma",
    "title": "Linked List",
    "tier": "Tier 4 - Data Structures",
    "description": "Classic data structure.",
    "concepts": "structs, index-based references, data structure operations",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/12_linked_list.forma",
    "code": "# Linked List - Classic data structure\n# Demonstrates: structs, index-based references, data structure operations\n#\n# We simulate a linked list using parallel arrays since FORMA\n# doesn't have nullable references yet. This is similar to how\n# embedded systems often implement linked lists.\n\n# Node representation: values[i] is data, next[i] is next index (-1 = null)\n# Using parallel arrays as a node pool\n\n# Initialize list (returns head index, -1 = empty)\nf list_new() -> Int\n    0 - 1\n\n# Prepend value to front of list\nf list_prepend(ref mut values: [Int], ref mut next: [Int], head: Int, value: Int, free: Int) -> (Int, Int)\n    # Use free slot for new node\n    values[free] := value\n    next[free] := head\n    new_head := free\n    new_free := free + 1\n    (new_head, new_free)\n\n# Append value to end of list\nf list_append(ref mut values: [Int], ref mut next: [Int], head: Int, value: Int, free: Int) -> (Int, Int)\n    # Create new node\n    values[free] := value\n    next[free] := 0 - 1\n\n    if head == 0 - 1 then\n        # Empty list, new node becomes head\n        (free, free + 1)\n    else\n        # Find end of list\n        current := head\n        wh next[current] != 0 - 1\n            current := next[current]\n        next[current] := free\n        (head, free + 1)\n\n# Get length of list\nf list_length(next: [Int], head: Int) -> Int\n    count := 0\n    current := head\n    wh current != 0 - 1\n        count := count + 1\n        current := next[current]\n    count\n\n# Get value at index (0-based)\nf list_get(values: [Int], next: [Int], head: Int, index: Int) -> Int\n    current := head\n    i := 0\n    wh i < index && current != 0 - 1\n        current := next[current]\n        i := i + 1\n    if current == 0 - 1 then 0 - 1\n    else values[current]\n\n# Print list\nf list_print(values: [Int], next: [Int], head: Int) -> Unit\n    s := \"[\"\n    current := head\n    first := true\n    wh current != 0 - 1\n        if !first then\n            s := s + \" -> \"\n        s := s + f\"{values[current]}\"\n        first := false\n        current := next[current]\n    s := s + \"]\"\n    print(s)\n\n# Reverse list in place\nf list_reverse(ref mut next: [Int], head: Int) -> Int\n    prev := 0 - 1\n    current := head\n    wh current != 0 - 1\n        next_node := next[current]\n        next[current] := prev\n        prev := current\n        current := next_node\n    prev\n\nf main()\n    # Allocate node pool (max 100 nodes)\n    values := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    next := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    print(\"Building linked list:\")\n    head := 0 - 1\n    free := 0\n\n    # Append 1, 2, 3, 4, 5\n    result := list_append(ref mut values, ref mut next, head, 1, free)\n    head := result.0\n    free := result.1\n\n    result := list_append(ref mut values, ref mut next, head, 2, free)\n    head := result.0\n    free := result.1\n\n    result := list_append(ref mut values, ref mut next, head, 3, free)\n    head := result.0\n    free := result.1\n\n    result := list_append(ref mut values, ref mut next, head, 4, free)\n    head := result.0\n    free := result.1\n\n    result := list_append(ref mut values, ref mut next, head, 5, free)\n    head := result.0\n    free := result.1\n\n    print(\"List after appending 1,2,3,4,5:\")\n    list_print(values, next, head)\n    print(f\"Length: {list_length(next, head)}\")\n\n    print(\"\")\n    print(\"Prepending 0:\")\n    result := list_prepend(ref mut values, ref mut next, head, 0, free)\n    head := result.0\n    free := result.1\n    list_print(values, next, head)\n\n    print(\"\")\n    print(f\"Element at index 0: {list_get(values, next, head, 0)}\")\n    print(f\"Element at index 3: {list_get(values, next, head, 3)}\")\n\n    print(\"\")\n    print(\"Reversing list:\")\n    head := list_reverse(ref mut next, head)\n    list_print(values, next, head)\n"
  },
  {
    "id": "13_binary_tree",
    "file": "13_binary_tree.forma",
    "title": "Binary Search Tree",
    "tier": "Tier 4 - Data Structures",
    "description": "Classic data structure.",
    "concepts": "tree structures, recursion, in-order traversal",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/13_binary_tree.forma",
    "code": "# Binary Search Tree - Classic data structure\n# Demonstrates: tree structures, recursion, in-order traversal\n#\n# Using parallel arrays: values[i], left[i], right[i]\n# -1 represents null/empty\n\n# Insert value into BST, returns root\nf bst_insert(ref mut values: [Int], ref mut left: [Int], ref mut right: [Int], root: Int, value: Int, free: Int) -> (Int, Int)\n    if root == 0 - 1 then\n        # Empty tree, create root\n        values[free] := value\n        left[free] := 0 - 1\n        right[free] := 0 - 1\n        (free, free + 1)\n    else\n        # Find insertion point\n        current := root\n        done := false\n        wh !done\n            if value < values[current] then\n                if left[current] == 0 - 1 then\n                    # Insert here\n                    values[free] := value\n                    left[free] := 0 - 1\n                    right[free] := 0 - 1\n                    left[current] := free\n                    done := true\n                else\n                    current := left[current]\n            else\n                if right[current] == 0 - 1 then\n                    # Insert here\n                    values[free] := value\n                    left[free] := 0 - 1\n                    right[free] := 0 - 1\n                    right[current] := free\n                    done := true\n                else\n                    current := right[current]\n        (root, free + 1)\n\n# Search for value in BST\nf bst_search(values: [Int], left: [Int], right: [Int], root: Int, target: Int) -> Bool\n    current := root\n    wh current != 0 - 1\n        if values[current] == target then\n            return true\n        else if target < values[current] then\n            current := left[current]\n        else\n            current := right[current]\n    false\n\n# In-order traversal (prints sorted order)\nf bst_inorder(values: [Int], left: [Int], right: [Int], node: Int) -> Unit\n    if node != 0 - 1 then\n        bst_inorder(values, left, right, left[node])\n        print(values[node])\n        bst_inorder(values, left, right, right[node])\n\n# Find minimum value\nf bst_min(values: [Int], left: [Int], root: Int) -> Int\n    if root == 0 - 1 then 0 - 1\n    else\n        current := root\n        wh left[current] != 0 - 1\n            current := left[current]\n        values[current]\n\n# Find maximum value\nf bst_max(values: [Int], right: [Int], root: Int) -> Int\n    if root == 0 - 1 then 0 - 1\n    else\n        current := root\n        wh right[current] != 0 - 1\n            current := right[current]\n        values[current]\n\n# Calculate tree height\nf bst_height(left: [Int], right: [Int], node: Int) -> Int\n    if node == 0 - 1 then 0\n    else\n        left_h := bst_height(left, right, left[node])\n        right_h := bst_height(left, right, right[node])\n        1 + (if left_h > right_h then left_h else right_h)\n\n# Count nodes\nf bst_count(left: [Int], right: [Int], node: Int) -> Int\n    if node == 0 - 1 then 0\n    else\n        1 + bst_count(left, right, left[node]) + bst_count(left, right, right[node])\n\nf main()\n    # Allocate node pool\n    values := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    left := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    right := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    print(\"Building BST with values: 50, 30, 70, 20, 40, 60, 80\")\n    root := 0 - 1\n    free := 0\n\n    # Build tree\n    result := bst_insert(ref mut values, ref mut left, ref mut right, root, 50, free)\n    root := result.0\n    free := result.1\n\n    result := bst_insert(ref mut values, ref mut left, ref mut right, root, 30, free)\n    root := result.0\n    free := result.1\n\n    result := bst_insert(ref mut values, ref mut left, ref mut right, root, 70, free)\n    root := result.0\n    free := result.1\n\n    result := bst_insert(ref mut values, ref mut left, ref mut right, root, 20, free)\n    root := result.0\n    free := result.1\n\n    result := bst_insert(ref mut values, ref mut left, ref mut right, root, 40, free)\n    root := result.0\n    free := result.1\n\n    result := bst_insert(ref mut values, ref mut left, ref mut right, root, 60, free)\n    root := result.0\n    free := result.1\n\n    result := bst_insert(ref mut values, ref mut left, ref mut right, root, 80, free)\n    root := result.0\n    free := result.1\n\n    print(\"\")\n    print(\"In-order traversal (sorted):\")\n    bst_inorder(values, left, right, root)\n\n    print(\"\")\n    print(\"Tree statistics:\")\n    print(f\"Node count: {bst_count(left, right, root)}\")\n    print(f\"Height: {bst_height(left, right, root)}\")\n    print(f\"Minimum: {bst_min(values, left, root)}\")\n    print(f\"Maximum: {bst_max(values, right, root)}\")\n\n    print(\"\")\n    print(\"Search tests:\")\n    print(f\"Search 40: {bst_search(values, left, right, root, 40)}\")  # true\n    print(f\"Search 25: {bst_search(values, left, right, root, 25)}\")  # false\n    print(f\"Search 70: {bst_search(values, left, right, root, 70)}\")  # true\n"
  },
  {
    "id": "14_sudoku",
    "file": "14_sudoku.forma",
    "title": "Sudoku Solver",
    "tier": "Tier 5 - Advanced",
    "description": "Constraint satisfaction with backtracking.",
    "concepts": "2D array manipulation, backtracking, constraint checking",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/14_sudoku.forma",
    "code": "# Sudoku Solver - Constraint satisfaction with backtracking\n# Demonstrates: 2D array manipulation, backtracking, constraint checking\n#\n# A 9x9 grid represented as flat array (grid[row*9 + col])\n# Empty cells are 0, filled cells are 1-9\n\n# Get value at (row, col)\nf get_cell(grid: [Int], row: Int, col: Int) -> Int\n    grid[row * 9 + col]\n\n# Set value at (row, col)\nf set_cell(ref mut grid: [Int], row: Int, col: Int, value: Int) -> Unit\n    grid[row * 9 + col] := value\n\n# Check if placing value at (row, col) is valid\nf is_valid(grid: [Int], row: Int, col: Int, value: Int) -> Bool\n    # Check row\n    c := 0\n    wh c < 9\n        if get_cell(grid, row, c) == value then\n            return false\n        c := c + 1\n\n    # Check column\n    r := 0\n    wh r < 9\n        if get_cell(grid, r, col) == value then\n            return false\n        r := r + 1\n\n    # Check 3x3 box\n    box_row := (row / 3) * 3\n    box_col := (col / 3) * 3\n    r := 0\n    wh r < 3\n        c := 0\n        wh c < 3\n            if get_cell(grid, box_row + r, box_col + c) == value then\n                return false\n            c := c + 1\n        r := r + 1\n\n    true\n\n# Find next empty cell, returns (row, col) or (-1, -1) if none\nf find_empty(grid: [Int]) -> (Int, Int)\n    r := 0\n    wh r < 9\n        c := 0\n        wh c < 9\n            if get_cell(grid, r, c) == 0 then\n                return (r, c)\n            c := c + 1\n        r := r + 1\n    (0 - 1, 0 - 1)\n\n# Solve sudoku using backtracking\nf solve(ref mut grid: [Int]) -> Bool\n    pos := find_empty(grid)\n    row := pos.0\n    col := pos.1\n\n    if row == 0 - 1 then\n        return true  # No empty cells, solved!\n\n    value := 1\n    wh value <= 9\n        if is_valid(grid, row, col, value) then\n            set_cell(ref mut grid, row, col, value)\n            if solve(ref mut grid) then\n                return true\n            set_cell(ref mut grid, row, col, 0)  # Backtrack\n        value := value + 1\n\n    false\n\n# Print sudoku grid\nf print_grid(grid: [Int]) -> Unit\n    r := 0\n    wh r < 9\n        if r % 3 == 0 && r != 0 then\n            print(\"------+-------+------\")\n        line := \"\"\n        c := 0\n        wh c < 9\n            if c % 3 == 0 && c != 0 then\n                line := line + \"| \"\n            val := get_cell(grid, r, c)\n            if val == 0 then\n                line := line + \". \"\n            else\n                line := line + f\"{val} \"\n            c := c + 1\n        print(line)\n        r := r + 1\n\nf main()\n    # Example puzzle (0 = empty)\n    # A medium difficulty puzzle\n    grid := [\n        5, 3, 0, 0, 7, 0, 0, 0, 0,\n        6, 0, 0, 1, 9, 5, 0, 0, 0,\n        0, 9, 8, 0, 0, 0, 0, 6, 0,\n        8, 0, 0, 0, 6, 0, 0, 0, 3,\n        4, 0, 0, 8, 0, 3, 0, 0, 1,\n        7, 0, 0, 0, 2, 0, 0, 0, 6,\n        0, 6, 0, 0, 0, 0, 2, 8, 0,\n        0, 0, 0, 4, 1, 9, 0, 0, 5,\n        0, 0, 0, 0, 8, 0, 0, 7, 9\n    ]\n\n    print(\"Sudoku Puzzle:\")\n    print(\"\")\n    print_grid(grid)\n\n    print(\"\")\n    print(\"Solving...\")\n\n    if solve(ref mut grid) then\n        print(\"\")\n        print(\"Solution:\")\n        print(\"\")\n        print_grid(grid)\n    else\n        print(\"No solution exists!\")\n"
  },
  {
    "id": "15_matrix_mult",
    "file": "15_matrix_mult.forma",
    "title": "Matrix Multiplication",
    "tier": "Tier 5 - Advanced",
    "description": "Computational benchmark.",
    "concepts": "nested loops, 2D array operations, O(n^3) algorithm",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/15_matrix_mult.forma",
    "code": "# Matrix Multiplication - Computational benchmark\n# Demonstrates: nested loops, 2D array operations, O(n^3) algorithm\n#\n# Matrices stored as flat arrays: matrix[row * cols + col]\n\n# Matrix dimensions (for demonstration)\n# A is m x n, B is n x p, result C is m x p\n\n# Get element at (row, col) in matrix with given column count\nf mat_get(mat: [Int], row: Int, col: Int, cols: Int) -> Int\n    mat[row * cols + col]\n\n# Set element at (row, col)\nf mat_set(ref mut mat: [Int], row: Int, col: Int, cols: Int, value: Int) -> Unit\n    mat[row * cols + col] := value\n\n# Multiply matrices A (m x n) and B (n x p), result in C (m x p)\nf mat_mult(a: [Int], b: [Int], ref mut c: [Int], m: Int, n: Int, p: Int) -> Unit\n    i := 0\n    wh i < m\n        j := 0\n        wh j < p\n            sum := 0\n            k := 0\n            wh k < n\n                sum := sum + mat_get(a, i, k, n) * mat_get(b, k, j, p)\n                k := k + 1\n            mat_set(ref mut c, i, j, p, sum)\n            j := j + 1\n        i := i + 1\n\n# Print matrix\nf mat_print(mat: [Int], rows: Int, cols: Int, name: String) -> Unit\n    print(f\"{name}:\")\n    r := 0\n    wh r < rows\n        line := \"  [\"\n        c := 0\n        wh c < cols\n            if c > 0 then\n                line := line + \", \"\n            val := mat_get(mat, r, c, cols)\n            line := line + f\"{val}\"\n            c := c + 1\n        line := line + \"]\"\n        print(line)\n        r := r + 1\n\n# Identity matrix check\nf mat_is_identity(mat: [Int], n: Int) -> Bool\n    i := 0\n    wh i < n\n        j := 0\n        wh j < n\n            expected := if i == j then 1 else 0\n            if mat_get(mat, i, j, n) != expected then\n                return false\n            j := j + 1\n        i := i + 1\n    true\n\nf main()\n    # Example 1: 2x3 * 3x2 = 2x2\n    print(\"Example 1: 2x3 * 3x2 = 2x2\")\n    print(\"\")\n\n    a1 := [1, 2, 3, 4, 5, 6]  # 2x3\n    b1 := [7, 8, 9, 10, 11, 12]  # 3x2\n    c1 := [0, 0, 0, 0]  # 2x2 result\n\n    mat_print(a1, 2, 3, \"A\")\n    print(\"\")\n    mat_print(b1, 3, 2, \"B\")\n    print(\"\")\n\n    mat_mult(a1, b1, ref mut c1, 2, 3, 2)\n    mat_print(c1, 2, 2, \"A * B\")\n\n    print(\"\")\n    print(\"=\" * 40)\n    print(\"\")\n\n    # Example 2: 3x3 * 3x3 = 3x3\n    print(\"Example 2: 3x3 * 3x3 = 3x3\")\n    print(\"\")\n\n    a2 := [1, 2, 3, 4, 5, 6, 7, 8, 9]  # 3x3\n    b2 := [9, 8, 7, 6, 5, 4, 3, 2, 1]  # 3x3\n    c2 := [0, 0, 0, 0, 0, 0, 0, 0, 0]  # 3x3 result\n\n    mat_print(a2, 3, 3, \"A\")\n    print(\"\")\n    mat_print(b2, 3, 3, \"B\")\n    print(\"\")\n\n    mat_mult(a2, b2, ref mut c2, 3, 3, 3)\n    mat_print(c2, 3, 3, \"A * B\")\n\n    print(\"\")\n    print(\"=\" * 40)\n    print(\"\")\n\n    # Example 3: Identity matrix\n    print(\"Example 3: A * I = A\")\n    print(\"\")\n\n    identity := [1, 0, 0, 0, 1, 0, 0, 0, 1]  # 3x3 identity\n    result := [0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    mat_mult(a2, identity, ref mut result, 3, 3, 3)\n    mat_print(a2, 3, 3, \"A\")\n    print(\"\")\n    mat_print(identity, 3, 3, \"I\")\n    print(\"\")\n    mat_print(result, 3, 3, \"A * I\")\n"
  },
  {
    "id": "16_game_of_life",
    "file": "16_game_of_life.forma",
    "title": "Conway's Game of Life",
    "tier": "Tier 5 - Advanced",
    "description": "Cellular automaton.",
    "concepts": "2D arrays, simulation, neighbor counting",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/16_game_of_life.forma",
    "code": "# Conway's Game of Life - Cellular automaton\n# Demonstrates: 2D arrays, simulation, neighbor counting\n#\n# Rules:\n#   1. Live cell with 2-3 neighbors survives\n#   2. Dead cell with exactly 3 neighbors becomes alive\n#   3. All other cells die or stay dead\n\n# Grid size\n# Using 20x20 grid stored as flat array\n\n# Get cell state at (row, col) with wrapping\nf get_cell_wrap(grid: [Int], row: Int, col: Int, size: Int) -> Int\n    r := (row + size) % size\n    c := (col + size) % size\n    grid[r * size + c]\n\n# Set cell state\nf set_cell(ref mut grid: [Int], row: Int, col: Int, size: Int, value: Int) -> Unit\n    grid[row * size + col] := value\n\n# Count live neighbors (with wrapping)\nf count_neighbors(grid: [Int], row: Int, col: Int, size: Int) -> Int\n    count := 0\n    dr := 0 - 1\n    wh dr <= 1\n        dc := 0 - 1\n        wh dc <= 1\n            if dr != 0 || dc != 0 then\n                count := count + get_cell_wrap(grid, row + dr, col + dc, size)\n            dc := dc + 1\n        dr := dr + 1\n    count\n\n# Compute next generation\nf next_generation(current: [Int], ref mut next: [Int], size: Int) -> Unit\n    r := 0\n    wh r < size\n        c := 0\n        wh c < size\n            neighbors := count_neighbors(current, r, c, size)\n            alive := get_cell_wrap(current, r, c, size) == 1\n\n            if alive then\n                # Live cell survives with 2-3 neighbors\n                if neighbors == 2 || neighbors == 3 then\n                    set_cell(ref mut next, r, c, size, 1)\n                else\n                    set_cell(ref mut next, r, c, size, 0)\n            else\n                # Dead cell becomes alive with exactly 3 neighbors\n                if neighbors == 3 then\n                    set_cell(ref mut next, r, c, size, 1)\n                else\n                    set_cell(ref mut next, r, c, size, 0)\n\n            c := c + 1\n        r := r + 1\n\n# Copy grid\nf copy_grid(src: [Int], ref mut dst: [Int], len: Int) -> Unit\n    i := 0\n    wh i < len\n        dst[i] := src[i]\n        i := i + 1\n\n# Print grid\nf print_grid(grid: [Int], size: Int, gen: Int) -> Unit\n    print(f\"Generation {gen}:\")\n    r := 0\n    wh r < size\n        line := \"\"\n        c := 0\n        wh c < size\n            if get_cell_wrap(grid, r, c, size) == 1 then\n                line := line + \"#\"\n            else\n                line := line + \".\"\n            c := c + 1\n        print(line)\n        r := r + 1\n    print(\"\")\n\n# Count total live cells\nf count_alive(grid: [Int], size: Int) -> Int\n    count := 0\n    i := 0\n    wh i < size * size\n        count := count + grid[i]\n        i := i + 1\n    count\n\nf main()\n    size := 10\n\n    # Initialize grids (10x10 = 100 cells)\n    grid1 := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    grid2 := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    # Set up a \"glider\" pattern\n    #   .#.\n    #   ..#\n    #   ###\n    set_cell(ref mut grid1, 1, 2, size, 1)\n    set_cell(ref mut grid1, 2, 3, size, 1)\n    set_cell(ref mut grid1, 3, 1, size, 1)\n    set_cell(ref mut grid1, 3, 2, size, 1)\n    set_cell(ref mut grid1, 3, 3, size, 1)\n\n    print(\"Conway's Game of Life - Glider Pattern\")\n    print(\"\")\n\n    # Run simulation for 20 generations\n    gen := 0\n    wh gen <= 20\n        print_grid(grid1, size, gen)\n        print(f\"Live cells: {count_alive(grid1, size)}\")\n        print(\"\")\n\n        # Compute next generation\n        next_generation(grid1, ref mut grid2, size)\n        copy_grid(grid2, ref mut grid1, size * size)\n\n        gen := gen + 1\n"
  },
  {
    "id": "17_verified_sort",
    "file": "17_verified_sort.forma",
    "title": "Verified Sort",
    "tier": "Tier 6 - Verification UX",
    "description": "Contract-driven sorting guarantees.",
    "concepts": "@pre/@post, @sorted, @permutation, explain/verify UX",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/17_verified_sort.forma",
    "code": "# Verified Sort - Contract-driven sorting guarantees\n# Demonstrates: @pre/@post, @sorted, @permutation, explain/verify UX\n\n@pre(items.len() > 0, \"input must be non-empty\")\n@sorted(result)\n@permutation(items, result)\nf verified_sort(items: [Int]) -> [Int]\n    sort_ints(items)\n\nf main()\n    input := [9, 3, 5, 1, 5, 2]\n    output := verified_sort(input)\n    print(\"Verified sort demo\")\n    print(f\"  input:  {input}\")\n    print(f\"  output: {output}\")\n    print(\"Try:\")\n    print(\"  forma explain --examples examples/showcase/17_verified_sort.forma\")\n    print(\"  forma verify --report examples/showcase/17_verified_sort.forma\")\n"
  },
  {
    "id": "17a_error_handling",
    "file": "17a_error_handling.forma",
    "title": "Error Handling",
    "tier": "Tier 6 - Verification UX",
    "description": "Option, Result, and safe patterns.",
    "concepts": "Option/Result types, pattern matching, ? operator,",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/17a_error_handling.forma",
    "code": "# Error Handling - Option, Result, and safe patterns\n# Demonstrates: Option/Result types, pattern matching, ? operator,\n#               ?? coalesce, builtins (is_some, unwrap, unwrap_or, etc.)\n\n# --- Option: representing optional values ---\n\n# Safe division returns None on divide-by-zero\nf safe_div(a: Int, b: Int) -> Int?\n    if b == 0 then None\n    else Some(a / b)\n\n# --- Result: representing success or failure ---\n\n# Parse a positive integer, returning an error message on failure\nf parse_positive(s: Str) -> Int!Str\n    m str_to_int(s)\n        Some(n) if n > 0 -> Ok(n)\n        Some(_) -> Err(\"not positive\")\n        None -> Err(\"not a number\")\n\n# --- Using the ? operator to propagate errors ---\n\nf add_two_numbers(a: Str, b: Str) -> Int!Str\n    x := parse_positive(a)?\n    y := parse_positive(b)?\n    Ok(x + y)\n\n# --- Demo functions ---\n\nf demo_option()\n    print(\"=== Option ===\")\n\n    # Creating Option values\n    some_val := Some(42)\n    none_val := None\n\n    # Pattern matching\n    m some_val\n        Some(v) -> print(f\"Some contains: {v}\")\n        None -> print(\"None\")\n\n    # Checking with builtins\n    print(f\"is_some(Some(42)) = {is_some(some_val)}\")\n    print(f\"is_none(Some(42)) = {is_none(some_val)}\")\n    print(f\"is_some(None) = {is_some(none_val)}\")\n    print(f\"is_none(None) = {is_none(none_val)}\")\n\n    # Unwrapping\n    print(f\"unwrap(Some(42)) = {unwrap(some_val)}\")\n    print(f\"unwrap_or(Some(42), 0) = {unwrap_or(some_val, 0)}\")\n    print(f\"unwrap_or(None, 99) = {unwrap_or(none_val, 99)}\")\n    print(f\"expect(Some(42), \\\"oops\\\") = {expect(some_val, \"oops\")}\")\n\n    # Coalesce operator ??\n    name := Some(\"Alice\") ?? \"unknown\"\n    fallback := None ?? \"default\"\n    print(f\"Some(\\\"Alice\\\") ?? \\\"unknown\\\" = {name}\")\n    print(f\"None ?? \\\"default\\\" = {fallback}\")\n\n    print(\"\")\n\nf demo_result()\n    print(\"=== Result ===\")\n\n    ok_val := Ok(100)\n    err_val := Err(\"something went wrong\")\n\n    # Pattern matching\n    m ok_val\n        Ok(v) -> print(f\"Ok contains: {v}\")\n        Err(e) -> print(f\"Err: {e}\")\n\n    m err_val\n        Ok(v) -> print(f\"Ok: {v}\")\n        Err(e) -> print(f\"Err contains: {e}\")\n\n    # Checking with builtins\n    print(f\"is_ok(Ok(100)) = {is_ok(ok_val)}\")\n    print(f\"is_err(Ok(100)) = {is_err(ok_val)}\")\n    print(f\"is_ok(Err(..)) = {is_ok(err_val)}\")\n    print(f\"is_err(Err(..)) = {is_err(err_val)}\")\n\n    print(\"\")\n\nf demo_try_operator()\n    print(\"=== Try Operator ? ===\")\n\n    # Success path: both parse as positive\n    m add_two_numbers(\"3\", \"4\")\n        Ok(v) -> print(f\"add_two_numbers(\\\"3\\\", \\\"4\\\") = Ok({v})\")\n        Err(e) -> print(f\"add_two_numbers(\\\"3\\\", \\\"4\\\") = Err({e})\")\n\n    # Failure path: second arg is not a number\n    m add_two_numbers(\"3\", \"abc\")\n        Ok(v) -> print(f\"add_two_numbers(\\\"3\\\", \\\"abc\\\") = Ok({v})\")\n        Err(e) -> print(f\"add_two_numbers(\\\"3\\\", \\\"abc\\\") = Err({e})\")\n\n    # Failure path: negative number\n    m add_two_numbers(\"5\", \"-1\")\n        Ok(v) -> print(f\"add_two_numbers(\\\"5\\\", \\\"-1\\\") = Ok({v})\")\n        Err(e) -> print(f\"add_two_numbers(\\\"5\\\", \\\"-1\\\") = Err({e})\")\n\n    print(\"\")\n\nf demo_practical()\n    print(\"=== Practical Patterns ===\")\n\n    # Safe division with pattern matching\n    m safe_div(10, 3)\n        Some(v) -> print(f\"10 / 3 = {v}\")\n        None -> print(\"division by zero!\")\n\n    m safe_div(10, 0)\n        Some(v) -> print(f\"10 / 0 = {v}\")\n        None -> print(\"10 / 0 = division by zero!\")\n\n    # Safe division with default via ??\n    result := safe_div(10, 0) ?? 0\n    print(f\"safe_div(10, 0) ?? 0 = {result}\")\n\n    # String parsing with str_to_int\n    m str_to_int(\"42\")\n        Some(n) -> print(f\"str_to_int(\\\"42\\\") = Some({n})\")\n        None -> print(\"str_to_int(\\\"42\\\") = None\")\n\n    m str_to_int(\"abc\")\n        Some(n) -> print(f\"str_to_int(\\\"abc\\\") = Some({n})\")\n        None -> print(\"str_to_int(\\\"abc\\\") = None\")\n\n    # Safe array access with vec_get\n    arr := [10, 20, 30]\n    m vec_get(arr, 1)\n        Some(v) -> print(f\"vec_get(arr, 1) = Some({v})\")\n        None -> print(\"vec_get(arr, 1) = None\")\n\n    m vec_get(arr, 5)\n        Some(v) -> print(f\"vec_get(arr, 5) = Some({v})\")\n        None -> print(\"vec_get(arr, 5) = None\")\n\n    # Default value chains with ??\n    val := vec_get(arr, 99) ?? 0\n    print(f\"vec_get(arr, 99) ?? 0 = {val}\")\n\n    # Chaining: parse then default\n    parsed := str_to_int(\"hello\") ?? 0\n    print(f\"str_to_int(\\\"hello\\\") ?? 0 = {parsed}\")\n\n    print(\"\")\n\nf main()\n    demo_option()\n    demo_result()\n    demo_try_operator()\n    demo_practical()\n    print(\"Done!\")\n"
  },
  {
    "id": "18_verified_stack",
    "file": "18_verified_stack.forma",
    "title": "Verified Stack",
    "tier": "Tier 6 - Verification UX",
    "description": "old(...) postconditions over structural changes.",
    "concepts": "old(expr), tuple postconditions, preconditions",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/18_verified_stack.forma",
    "code": "# Verified Stack - old(...) postconditions over structural changes\n# Demonstrates: old(expr), tuple postconditions, preconditions\n\n@post(result.len() == old(stack).len() + 1)\n@post(result[result.len() - 1] == value)\nf stack_push(stack: [Int], value: Int) -> [Int]\n    next := stack\n    next = vec_push(next, value)\n    next\n\n@pre(stack.len() > 0, \"cannot pop from empty stack\")\n@post(result.0 == old(stack)[old(stack).len() - 1])\n@post(result.1.len() + 1 == old(stack).len())\nf stack_pop(stack: [Int]) -> (Int, [Int])\n    top := stack[len(stack) - 1]\n    rest := vec_slice(stack, 0, len(stack) - 1)\n    (top, rest)\n\nf main()\n    stack := [10, 20, 30]\n    pushed := stack_push(stack, 40)\n    popped := stack_pop(pushed)\n    print(\"Verified stack demo\")\n    print(f\"  after push: {pushed}\")\n    print(f\"  pop value:  {popped.0}\")\n    print(f\"  pop rest:   {popped.1}\")\n"
  },
  {
    "id": "19_verified_math",
    "file": "19_verified_math.forma",
    "title": "Verified Math",
    "tier": "Tier 6 - Verification UX",
    "description": "algebraic + collection invariants.",
    "concepts": "@nonzero, @same_length, @sorted, quantified postconditions",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/19_verified_math.forma",
    "code": "# Verified Math - algebraic + collection invariants\n# Demonstrates: @nonzero, @same_length, @sorted, quantified postconditions\n\n@nonzero(b)\n@post(result * b == a)\nf safe_div(a: Int, b: Int) -> Int\n    a / b\n\n@same_length(values, result)\n@sorted(result)\n@post(forall i in result: i >= 0)\nf normalize_and_sort(values: [Int]) -> [Int]\n    out := vec_new()\n    for v in values\n        out = vec_push(out, abs(v))\n    sort_ints(out)\n\nf main()\n    q := safe_div(84, 7)\n    normalized := normalize_and_sort([5, -3, 0, -12, 4])\n    print(\"Verified math demo\")\n    print(f\"  safe_div(84, 7) = {q}\")\n    print(f\"  normalize_and_sort(...) = {normalized}\")\n"
  },
  {
    "id": "20_verification_demo",
    "file": "20_verification_demo.forma",
    "title": "Verification UX Demo",
    "tier": "Tier 6 - Verification UX",
    "description": "Showcase program.",
    "concepts": "PASS + WARN categories in verify reports",
    "githubUrl": "https://github.com/sfw/forma/blob/main/examples/showcase/20_verification_demo.forma",
    "code": "# Verification UX Demo\n# Demonstrates: PASS + WARN categories in verify reports\n\n@pre(x >= 0, \"x must be non-negative\")\n@post(result >= x)\nf grows(x: Int) -> Int\n    x + 1\n\n# No contracts on purpose. verify --report should show WARN for this function.\nf helper_without_contracts(x: Int) -> Int\n    x * 2\n\nf main()\n    print(\"Verification UX demo\")\n    print(f\"  grows(4) = {grows(4)}\")\n    print(f\"  helper_without_contracts(4) = {helper_without_contracts(4)}\")\n    print(\"\")\n    print(\"Try:\")\n    print(\"  forma explain --examples examples/showcase/20_verification_demo.forma\")\n    print(\"  forma verify --report examples/showcase/20_verification_demo.forma\")\n"
  }
];
