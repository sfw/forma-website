<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="FORMA language reference: syntax, types, control flow, data model, async, standard library, tooling, and AI-first workflows.">
  <title>FORMA Language Reference | forma-lang.dev</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="reference.css">
</head>
<body class="reference-page">
  <div class="page-glow page-glow-a"></div>
  <div class="page-glow page-glow-b"></div>

  <header class="site-header">
    <a class="logo" href="index.html" aria-label="FORMA home">
      <span class="logo-mark">F</span>
      <span class="logo-text">FORMA</span>
    </a>
    <nav class="site-view-switcher" aria-label="Switch site view">
      <a href="index.html">Interactive</a>
      <a href="technical.html">Architecture</a>
      <a href="reference.html" aria-current="page">Reference</a>
    </nav>
    <a class="button ghost header-github github-button" href="https://github.com/sfw/forma" target="_blank" rel="noreferrer">
      <svg class="github-mark" viewBox="0 0 16 16" aria-hidden="true" focusable="false">
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52 0-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.5-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82a7.57 7.57 0 0 1 2-.27c.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8Z"></path>
      </svg>
      GitHub
    </a>
  </header>

  <main class="reference-main">
    <section class="section reference-hero reveal" id="overview">
      <p class="eyebrow">Language Manual</p>
      <h1>FORMA Reference</h1>
      <p class="reference-lede">
        This page is the complete web reference for FORMA syntax, semantics, runtime-facing features, and AI-first tooling surfaces.
        It combines a detailed human-readable guide with a compact pattern-oriented quick reference.
      </p>
      <div class="reference-chips">
        <span>Indentation-based syntax</span>
        <span>Second-class references</span>
        <span>Result/Option-first errors</span>
        <span>Async + spawn + await</span>
        <span>320+ builtins</span>
        <span>Grammar + JSON diagnostics</span>
      </div>
      <div class="reference-actions">
        <a class="button primary" href="#syntax">Start With Syntax</a>
        <a class="button" href="#tooling">Jump To CLI</a>
      </div>
    </section>

    <section class="section reference-layout">
      <aside class="reference-toc">
        <h2>On This Page</h2>
        <nav aria-label="Reference sections">
          <a href="#syntax">Syntax Basics</a>
          <a href="#showcase">Showcase Examples</a>
          <a href="#types">Type System</a>
          <a href="#control">Control Flow</a>
          <a href="#functions">Functions</a>
          <a href="#data-model">Structs, Enums, Match</a>
          <a href="#errors">Error Handling</a>
          <a href="#abstractions">Generics, Traits, Closures</a>
          <a href="#references">References and Borrow Rules</a>
          <a href="#modules">Modules and Contracts</a>
          <a href="#concurrency">Async and Concurrency</a>
          <a href="#stdlib">Standard Library</a>
          <a href="#tooling">Tooling and CLI</a>
          <a href="#ai-workflows">AI Workflows</a>
          <a href="#appendix">Keyword and Operator Appendix</a>
        </nav>
      </aside>

      <div class="reference-content">
        <section class="reference-block reveal" id="syntax">
          <h2>Syntax Basics</h2>
          <p>
            FORMA is indentation-significant, expression-oriented, and optimized for concise, unambiguous structure.
            Comments use <code>#</code>, and the last expression in a function body is its return value.
          </p>
          <div class="reference-grid two">
            <article>
              <h3>Build and Run</h3>
              <pre><code class="language-bash">git clone https://github.com/sfw/forma.git
cd forma
cargo build --release</code></pre>
            </article>
            <article>
              <h3>Hello World</h3>
              <pre><code class="language-forma">f main()
    print("Hello, World!")</code></pre>
            </article>
          </div>
          <p class="micro-note"><code>main</code> is the program entrypoint and should be declared as <code>f main()</code>.</p>
          <h3>Core Syntax Rules</h3>
          <ul>
            <li>Variables are written as <code>x := value</code>; explicit type form is <code>x: Type = value</code>.</li>
            <li>Single-expression function form uses <code>=</code>.</li>
            <li>Generics use <code>[T]</code> (not angle brackets).</li>
            <li>Keyword forms are short by design (<code>f</code>, <code>s</code>, <code>e</code>, <code>m</code>, <code>wh</code>, <code>lp</code>, <code>ret</code>).</li>
          </ul>
        </section>

        <section class="reference-block reveal" id="showcase">
          <h2>Showcase Examples</h2>
          <p>
            These canonical programs are used to stress the language across control flow, algorithms,
            data structures, and simulation tasks. Select any example to inspect the full source inline.
          </p>
          <div class="showcase-viewer" data-showcase-viewer>
            <div class="showcase-toolbar">
              <label for="showcaseSelect">Example</label>
              <select id="showcaseSelect" aria-label="Select showcase example"></select>
              <span class="showcase-tier" id="showcaseTier">Tier</span>
              <span class="showcase-concepts" id="showcaseConcepts">Concepts</span>
              <a
                id="showcaseSource"
                href="https://github.com/sfw/forma/tree/main/examples/showcase"
                target="_blank"
                rel="noreferrer"
              >
                Open source file
              </a>
            </div>
            <pre class="showcase-code"><code id="showcaseCode" class="language-forma"></code></pre>
          </div>
        </section>

        <section class="reference-block reveal" id="types">
          <h2>Type System</h2>
          <p>
            FORMA supports primitive, sized integer, collection, and algebraic types with explicit Option/Result forms.
            Inference covers most local variables and many return sites.
          </p>
          <div class="table-wrap">
            <table class="reference-table">
              <thead>
                <tr>
                  <th>Category</th>
                  <th>Syntax</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Primitives</td>
                  <td><code>Int</code> <code>Float</code> <code>Bool</code> <code>Char</code> <code>Str</code> <code>()</code></td>
                  <td>Default integer/float plus unit value.</td>
                </tr>
                <tr>
                  <td>Sized integers</td>
                  <td><code>i8..i128</code> <code>u8..u128</code> <code>isize</code> <code>usize</code></td>
                  <td>Use when storage and overflow behavior matter.</td>
                </tr>
                <tr>
                  <td>Collections</td>
                  <td><code>[T]</code> <code>[T; N]</code> <code>{K: V}</code> <code>(A, B)</code></td>
                  <td>List, fixed array, map, tuple.</td>
                </tr>
                <tr>
                  <td>Algebraic</td>
                  <td><code>T?</code> <code>T!E</code></td>
                  <td>Shorthand for Option and Result.</td>
                </tr>
                <tr>
                  <td>Function type</td>
                  <td><code>(A, B) -&gt; C</code></td>
                  <td>First-class callable type shape.</td>
                </tr>
              </tbody>
            </table>
          </div>
          <pre><code class="language-forma">f identity[T](x: T) -> T
    x

f first[T](list: [T]) -> T?
    if len(list) > 0 then Some(list[0])
    else None

s Stack[T]
    items: [T]
    size: Int</code></pre>
        </section>

        <section class="reference-block reveal" id="control">
          <h2>Control Flow</h2>
          <p>
            Conditionals and matches are expression-capable. Loop forms include while, for-in, and infinite loop, with short control keywords.
          </p>
          <div class="reference-grid two">
            <article>
              <h3>If / Else</h3>
              <pre><code class="language-forma"># Single-expression form
result := if x > 0 then "positive" else "non-positive"

# Block form
if x > 0
    print("positive")
else if x == 0
    print("zero")
else
    print("negative")</code></pre>
            </article>
            <article>
              <h3>Loops</h3>
              <pre><code class="language-forma">i := 0
wh i &lt; 10
    print(i)
    i := i + 1</code></pre>
              <pre><code class="language-forma">'outer: for i in [1, 2, 3]
    for j in [10, 20, 30]
        if i * j > 40 then br 'outer
        print(f"{i} * {j} = {i * j}")</code></pre>
            </article>
          </div>
          <div class="inline-notes">
            <span><code>br</code> break</span>
            <span><code>ct</code> continue</span>
            <span><code>ret</code> return</span>
            <span><code>lp</code> infinite loop</span>
          </div>
        </section>

        <section class="reference-block reveal" id="functions">
          <h2>Functions</h2>
          <p>
            Functions are declared with <code>f</code>. Use block bodies for multi-step logic and <code>=</code> for compact one-liners.
          </p>
<pre><code class="language-forma">f add(a: Int, b: Int) -> Int
    a + b

f greet(name: Str) -> Str
    f"Hello, {name}!"</code></pre>
          <pre><code class="language-forma">f double(x: Int) -> Int = x * 2
f is_even(n: Int) -> Bool = n % 2 == 0
</code></pre>
          <pre><code class="language-forma">f is_prime(n: Int) -> Bool
    if n &lt; 2 then return false
    if n == 2 then return true
    if n % 2 == 0 then return false
    i := 3
    wh i * i &lt;= n
        if n % i == 0 then return false
        i := i + 2
    true</code></pre>
          <p>
            Async functions are prefixed with <code>as</code>. Await uses <code>aw</code> and task creation uses <code>sp</code>.
          </p>
        </section>

        <section class="reference-block reveal" id="data-model">
          <h2>Structs, Enums, and Pattern Matching</h2>
          <p>
            Data modeling centers on structs and enums, with exhaustive pattern matching as the primary branching tool.
          </p>
          <div class="reference-grid two">
            <article>
              <h3>Structs and Methods</h3>
<pre><code class="language-forma">s Point
    x: Float
    y: Float

i Point
    f distance(&amp;self) -> Float
        sqrt(self.x * self.x + self.y * self.y)

    f translate(&amp;self, dx: Float, dy: Float) -> Point
        Point { x: self.x + dx, y: self.y + dy }

f main()
    p := Point { x: 3.0, y: 4.0 }
    print(p.distance())  # 5.0</code></pre>
            </article>
            <article>
              <h3>Enums and Match</h3>
              <pre><code class="language-forma">e Direction
    North
    South
    East
    West

e Shape
    Circle(Float)
    Rectangle(Float, Float)
    Triangle(Float, Float, Float)</code></pre>
              <pre><code class="language-forma">f describe(n: Int) -> Str
    m n
        0 -> "zero"
        1 -> "one"
        _ -> "many"</code></pre>
            </article>
          </div>
          <p>
            Match arms support literals, tuple/struct destructuring, wildcard <code>_</code>, and guards with <code>if</code>.
          </p>
        </section>

        <section class="reference-block reveal" id="errors">
          <h2>Error Handling</h2>
          <p>
            FORMA uses explicit value-based errors: <code>T?</code> for optional values and <code>T!E</code> for fallible operations.
            The language avoids exception-style control flow.
          </p>
          <pre><code class="language-forma">f parse_positive(s: Str) -> Int!Str
    n := str_to_int(s)
    m n
        Some(v) if v > 0 -> Ok(v)
        Some(_) -> Err("not positive")
        None -> Err("not a number")</code></pre>
          <pre><code class="language-forma">f read_config(path: Str) -> Str!Str
    content := file_read(path)?    # Returns Err if file_read fails
    Ok(content)</code></pre>
          <pre><code class="language-forma">f main()
    name := env_get("USER") ?? "unknown"
    print(f"Hello, {name}")</code></pre>
          <div class="inline-notes">
            <span><code>?</code> propagate error</span>
            <span><code>!</code> unwrap or panic</span>
            <span><code>??</code> coalesce default value</span>
          </div>
          <h3>Option/Result Utilities</h3>
          <div class="table-wrap">
            <table class="reference-table">
              <thead>
                <tr>
                  <th>Function</th>
                  <th>Signature</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>is_some</code></td>
                  <td><code>Option[T] -&gt; Bool</code></td>
                  <td><code>true</code> if <code>Some</code>.</td>
                </tr>
                <tr>
                  <td><code>is_none</code></td>
                  <td><code>Option[T] -&gt; Bool</code></td>
                  <td><code>true</code> if <code>None</code>.</td>
                </tr>
                <tr>
                  <td><code>is_ok</code></td>
                  <td><code>Result[T, E] -&gt; Bool</code></td>
                  <td><code>true</code> if <code>Ok</code>.</td>
                </tr>
                <tr>
                  <td><code>is_err</code></td>
                  <td><code>Result[T, E] -&gt; Bool</code></td>
                  <td><code>true</code> if <code>Err</code>.</td>
                </tr>
                <tr>
                  <td><code>unwrap</code></td>
                  <td><code>Option[T] -&gt; T</code></td>
                  <td>Extract value, panic on <code>None</code>.</td>
                </tr>
                <tr>
                  <td><code>unwrap_or</code></td>
                  <td><code>(Option[T], T) -&gt; T</code></td>
                  <td>Extract or return default.</td>
                </tr>
                <tr>
                  <td><code>expect</code></td>
                  <td><code>(Option[T], Str) -&gt; T</code></td>
                  <td>Extract or panic with custom message.</td>
                </tr>
              </tbody>
            </table>
          </div>
          <pre><code class="language-forma"># Check status
is_some(Some(42))       # true
is_none(None)           # true
is_ok(Ok(42))           # true
is_err(Err("bad"))      # true

# Unwrapping (Option only)
unwrap(Some(42))             # 42
unwrap_or(Some(42), 0)      # 42
unwrap_or(None, 0)          # 0
expect(Some(42), "missing")  # 42</code></pre>
          <h3>Pattern Matching on Option/Result</h3>
          <pre><code class="language-forma">f describe(opt: Int?) -> Str
    m opt
        Some(v) -> f"got {v}"
        None -> "nothing"

f handle(res: Int!Str) -> Str
    m res
        Ok(v) -> f"success: {v}"
        Err(e) -> f"error: {e}"</code></pre>
          <pre><code class="language-forma">f classify(opt: Int?) -> Str
    m opt
        Some(n) if n > 0 -> "positive"
        Some(n) if n &lt; 0 -> "negative"
        Some(_) -> "zero"
        None -> "absent"</code></pre>
          <h3>Practical Patterns</h3>
          <pre><code class="language-forma">f safe_div(a: Int, b: Int) -> Int?
    if b == 0 then None
    else Some(a / b)

f main()
    result := safe_div(10, 0) ?? 0    # 0</code></pre>
          <pre><code class="language-forma">f parse_positive(s: Str) -> Int!Str
    m str_to_int(s)
        Some(n) if n > 0 -> Ok(n)
        Some(_) -> Err("not positive")
        None -> Err("not a number")

f add_parsed(a: Str, b: Str) -> Int!Str
    x := parse_positive(a)?    # Returns Err early if parsing fails
    y := parse_positive(b)?
    Ok(x + y)</code></pre>
          <pre><code class="language-forma">f main()
    # These are equivalent for Option values:
    a := unwrap_or(str_to_int("abc"), 0)
    b := str_to_int("abc") ?? 0</code></pre>
          <pre><code class="language-forma"># str_to_int: Str -> Int?
m str_to_int("42")
    Some(n) -> print(n)    # 42
    None -> print("failed")

# vec_get: ([T], Int) -> T?
arr := [10, 20, 30]
m vec_get(arr, 1)
    Some(v) -> print(v)    # 20
    None -> print("out of bounds")</code></pre>
        </section>

        <section class="reference-block reveal" id="abstractions">
          <h2>Generics, Traits, and Closures</h2>
          <p>
            Reusable abstractions combine <code>[T]</code> generics, trait interfaces, and inline closures for higher-order operations.
          </p>
          <div class="reference-grid two">
            <article>
              <h3>Generics + Traits</h3>
<pre><code class="language-forma">t Display
    f display(&amp;self) -> Str

t Area
    f area(&amp;self) -> Float
</code></pre>
              <pre><code class="language-forma">f print_area[T](shape: T) -> Unit where T: Area + Display
    print(f"{shape.display()}: area = {shape.area()}")</code></pre>
            </article>
            <article>
              <h3>Closures</h3>
              <pre><code class="language-forma">f main()
    add := |a: Int, b: Int| a + b
    print(add(3, 4))          # 7

    square := |x: Int| -> Int x * x
    print(square(5))          # 25</code></pre>
              <pre><code class="language-forma">f apply(x: Int, func: (Int) -> Int) -> Int
    func(x)

f main()
    result := apply(5, |x: Int| x * 2)
    print(result)  # 10</code></pre>
            </article>
          </div>
        </section>

        <section class="reference-block reveal" id="references">
          <h2>References and Borrow Rules</h2>
          <p>
            FORMA uses second-class references: they are valid for parameter passing and local borrow semantics,
            but are restricted to keep lifetime analysis tractable.
          </p>
          <pre><code class="language-forma">f swap(ref mut arr: [Int], i: Int, j: Int) -> Unit
    temp := arr[i]
    arr[i] := arr[j]
    arr[j] := temp

f sort(ref mut arr: [Int]) -> Unit
    n := len(arr)
    if n > 1 then
        quicksort(ref mut arr, 0, n - 1)</code></pre>
          <pre><code class="language-forma">f main()
    data := [3, 1, 2]
    swap(ref mut data, 0, 2)
    print(data)                     # [2, 1, 3]</code></pre>
          <ul>
            <li>Multiple shared borrows are allowed.</li>
            <li>Only one mutable borrow is allowed at a time.</li>
            <li>Shared and mutable borrows cannot overlap.</li>
          </ul>
        </section>

        <section class="reference-block reveal" id="modules">
          <h2>Modules, Imports, and Contracts</h2>
          <div class="reference-grid two">
            <article>
              <h3>Modules and Imports</h3>
              <pre><code class="language-forma">us std.io
us std.collections
us std.math</code></pre>
              <pre><code class="language-forma">us collections.{Vec, Map}</code></pre>
              <pre><code class="language-forma">us std.fs -> filesystem</code></pre>
              <pre><code class="language-forma">pub md utils
    pub f helper() -> Int
        42</code></pre>
            </article>
            <article>
              <h3>Contracts</h3>
<pre><code class="language-forma">@pre(n >= 0, "n must be non-negative")
@post(result >= 1, "factorial is always positive")
f factorial(n: Int) -> Int
    if n &lt;= 1 then 1
    else n * factorial(n - 1)</code></pre>
              <p class="micro-note">Enable runtime contract checks with <code>forma run --check-contracts file.forma</code>.</p>
            </article>
          </div>
        </section>

        <section class="reference-block reveal" id="concurrency">
          <h2>Async and Concurrency</h2>
          <p>
            Async functions use <code>as f</code>, spawning uses <code>sp</code>, and awaiting uses <code>aw</code>.
            Channels and mutexes provide coordination primitives.
          </p>
          <pre><code class="language-forma">as f fetch_data(url: Str) -> Str!Str
    response := http_get(url)?
    Ok(response)</code></pre>
          <pre><code class="language-forma">as f main()
    # Spawn concurrent work
    task1 := sp fetch_data("https://api.example.com/a")
    task2 := sp fetch_data("https://api.example.com/b")

    # Await results
    result1 := aw task1
    result2 := aw task2
    print("Both complete!")</code></pre>
          <pre><code class="language-forma">as f main()
    ch := channel_new()
    sender := ch.0
    receiver := ch.1

    sp producer(sender)

    msg := channel_recv(receiver)
    print(msg)</code></pre>
        </section>

        <section class="reference-block reveal" id="stdlib">
          <h2>Standard Library Overview</h2>
          <p>
            FORMA exposes broad builtin coverage for I/O, text processing, math, data structures, networking, persistence, and diagnostics.
          </p>
          <div class="table-wrap">
            <table class="reference-table">
              <thead>
                <tr>
                  <th>Category</th>
                  <th>Representative Functions</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>I/O</td>
                  <td><code>print</code> <code>eprintln</code> <code>str</code></td>
                  <td>Core output + conversion primitives.</td>
                </tr>
                <tr>
                  <td>Strings</td>
                  <td><code>str_len</code> <code>str_split</code> <code>str_trim</code> <code>str_slice</code></td>
                  <td>Common text transforms and parsing helpers.</td>
                </tr>
                <tr>
                  <td>Collections</td>
                  <td><code>vec_push</code> <code>vec_pop</code> <code>map_get</code> <code>map_insert</code></td>
                  <td>List/map operations + utility functions.</td>
                </tr>
                <tr>
                  <td>Math</td>
                  <td><code>abs</code> <code>sqrt</code> <code>pow</code> <code>sin</code> <code>log</code></td>
                  <td>Numeric operations and transcendental math.</td>
                </tr>
                <tr>
                  <td>File I/O</td>
                  <td><code>file_read</code> <code>file_write</code> <code>dir_list</code></td>
                  <td>Requires capability flags (<code>--allow-read</code>, <code>--allow-write</code>).</td>
                </tr>
                <tr>
                  <td>Networking</td>
                  <td><code>http_get</code> <code>http_serve</code> <code>tcp_connect</code> <code>tls_connect</code></td>
                  <td>Requires <code>--allow-network</code>.</td>
                </tr>
                <tr>
                  <td>Database</td>
                  <td><code>db_open</code> <code>db_execute</code> <code>db_query</code></td>
                  <td>SQLite workflow with row extraction helpers.</td>
                </tr>
                <tr>
                  <td>JSON / Regex / Time / Random</td>
                  <td><code>json_parse</code> <code>regex_match</code> <code>time_now</code> <code>random_int</code></td>
                  <td>Common runtime features for service and tooling code.</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>

        <section class="reference-block reveal" id="tooling">
          <h2>Tooling and CLI</h2>
          <p>
            The CLI covers execution, checking, formatting, grammar export, project scaffolding, and editor-facing queries.
          </p>
          <pre><code class="language-bash">forma run &lt;file&gt;                   # Run a FORMA program
forma run &lt;file&gt; --dump-mir        # Run with MIR dump
forma run &lt;file&gt; --check-contracts # Enable contract checking
forma run &lt;file&gt; --allow-read      # Allow file reads
forma run &lt;file&gt; --allow-write     # Allow file writes
forma run &lt;file&gt; --allow-network   # Allow networking
forma run &lt;file&gt; --allow-all       # Allow all capabilities
forma check &lt;file&gt;                 # Type check without running
forma check &lt;file&gt; --partial       # Partial checking
forma lex &lt;file&gt;                   # Dump tokens
forma parse &lt;file&gt;                 # Dump AST
forma grammar --format ebnf        # Export grammar as EBNF
forma grammar --format json        # Export grammar as JSON
forma fmt &lt;file&gt;                   # Format source code
forma repl                         # Interactive REPL
forma new &lt;name&gt;                   # Create new project
forma init                         # Initialize project in current dir
forma typeof &lt;file&gt; --position 5:10  # Query type at position
forma complete &lt;file&gt; --position 5:10  # Get completions</code></pre>
          <h3>Error Formats</h3>
          <div class="reference-grid two">
            <article>
              <p class="micro-note">Default (human-readable)</p>
              <pre><code>error[type_mismatch]: expected Int, found Str
  --&gt; main.forma:5:12</code></pre>
            </article>
            <article>
              <p class="micro-note">JSON mode (machine-readable)</p>
              <pre><code>{
  "success": false,
  "errors": [{
    "file": "main.forma",
    "line": 5,
    "column": 12,
    "severity": "error",
    "code": "type_mismatch",
    "message": "expected Int, found Str"
  }]
}</code></pre>
            </article>
          </div>
        </section>

        <section class="reference-block reveal" id="ai-workflows">
          <h2>AI Workflows</h2>
          <p>
            FORMA exposes dedicated surfaces for constrained generation, automated repair loops, and type-aware completions.
          </p>
          <div class="reference-grid two">
            <article>
              <h3>Constrained Syntax Generation</h3>
              <pre><code class="language-bash">forma grammar --format ebnf &gt; forma.ebnf
forma grammar --format json &gt; forma.json</code></pre>
              <p class="micro-note">Use grammar files to restrict decoding to valid FORMA syntax.</p>
            </article>
            <article>
              <h3>Repair Loop Inputs</h3>
              <pre><code class="language-bash">forma check --error-format json broken.forma</code></pre>
              <p class="micro-note">Type query: <code>forma typeof myfile.forma --position "5:10"</code>.</p>
              <p class="micro-note">Completions: <code>forma complete myfile.forma --position "5:10"</code>.</p>
            </article>
          </div>
          <h3>Token-Efficient Keyword Set</h3>
          <div class="inline-notes">
            <span><code>f</code> function</span>
            <span><code>s</code> struct</span>
            <span><code>e</code> enum</span>
            <span><code>m</code> match</span>
            <span><code>wh</code> while</span>
            <span><code>lp</code> loop</span>
            <span><code>as/aw/sp</code> async trio</span>
          </div>
        </section>

        <section class="reference-block reveal" id="appendix">
          <h2>Keyword and Operator Appendix</h2>
          <div class="reference-grid two">
            <article>
              <h3>Keywords</h3>
              <p class="micro-note">Core: <code>f s e t i m if then else for in wh lp br ct ret as aw sp us md pub mut ref mv un type where linear affine</code></p>
              <p class="micro-note">Literals/constructors: <code>true false T F none N Some Ok Err ok err</code></p>
            </article>
            <article>
              <h3>Operators</h3>
              <p class="micro-note">Arithmetic: <code>+ - * / %</code></p>
              <p class="micro-note">Comparison: <code>== != &lt; &lt;= &gt; &gt;=</code></p>
              <p class="micro-note">Logical: <code>&amp;&amp; || !</code></p>
              <p class="micro-note">Bitwise: <code>&amp; | ^ &lt;&lt; &gt;&gt;</code></p>
              <p class="micro-note">Special: <code>:= = += -= *= /= %= ? ?? -&gt; =&gt; .. ..= :: . @</code></p>
            </article>
          </div>
        </section>
      </div>
    </section>
  </main>

  <footer class="site-footer reference-footer">
    <p>FORMA</p>
    <div class="footer-controls">
      <a class="button tiny" href="#overview">Back to top</a>
      <nav class="site-view-switcher" aria-label="Switch site view">
        <a href="index.html">Interactive</a>
        <a href="technical.html">Architecture</a>
        <a href="reference.html" aria-current="page">Reference</a>
      </nav>
      <a class="button ghost github-button footer-github" href="https://github.com/sfw/forma" target="_blank" rel="noreferrer">
        <svg class="github-mark" viewBox="0 0 16 16" aria-hidden="true" focusable="false">
          <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52 0-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.5-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82a7.57 7.57 0 0 1 2-.27c.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8Z"></path>
        </svg>
        GitHub
      </a>
    </div>
  </footer>

  <script src="showcase-examples.js"></script>
  <script src="reference.js"></script>
</body>
</html>
